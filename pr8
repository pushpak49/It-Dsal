Implement binary search tree and perform following operations: a)Insert b)Search c)Display-Depth of
tree d)Display leaf node

#include <iostream>
using namespace std;

// Node structure for the Binary Search Tree
struct Node {
    int data;
    Node* left;
    Node* right;

    Node(int val) {
        data = val;
        left = nullptr;
        right = nullptr;
    }
};

// Binary Search Tree class
class BinarySearchTree {
private:
    Node* root;

    // Helper function for Insert operation
    Node* insert(Node* root, int value) {
        if (root == nullptr) {
            return new Node(value);  // Create a new node if root is null
        }

        if (value < root->data) {
            root->left = insert(root->left, value);  // Insert in the left subtree
        } else {
            root->right = insert(root->right, value); // Insert in the right subtree
        }
        return root;
    }

    // Helper function for Search operation
    bool search(Node* root, int value) {
        if (root == nullptr) {
            return false;  // Value not found
        }

        if (root->data == value) {
            return true;  // Value found
        }

        if (value < root->data) {
            return search(root->left, value);  // Search in the left subtree
        } else {
            return search(root->right, value);  // Search in the right subtree
        }
    }

    // Helper function to calculate the depth (height) of the tree
    int depth(Node* root) {
        if (root == nullptr) {
            return -1;  // Base case: height of empty tree is -1
        }
        int leftDepth = depth(root->left);
        int rightDepth = depth(root->right);
        return 1 + max(leftDepth, rightDepth);  // 1 + max of left and right subtree depths
    }

    // Helper function to display all leaf nodes
    void displayLeafNodes(Node* root) {
        if (root == nullptr) {
            return;
        }
        if (root->left == nullptr && root->right == nullptr) {
            cout << root->data << " ";  // Leaf node
        }
        displayLeafNodes(root->left);   // Check the left subtree
        displayLeafNodes(root->right);  // Check the right subtree
    }

    // Helper function for In-order traversal (used for displaying the tree)
    void inorder(Node* root) {
        if (root == nullptr) {
            return;
        }
        inorder(root->left);   // Visit left subtree
        cout << root->data << " "; // Visit root
        inorder(root->right);  // Visit right subtree
    }

public:
    // Constructor to initialize the BST
    BinarySearchTree() {
        root = nullptr;
    }

    // Public function to insert a value into the BST
    void insert(int value) {
        root = insert(root, value);
    }

    // Public function to search for a value in the BST
    bool search(int value) {
        return search(root, value);
    }

    // Public function to display the depth (height) of the tree
    int depth() {
        return depth(root);
    }

    // Public function to display all leaf nodes in the tree
    void displayLeafNodes() {
        cout << "Leaf nodes: ";
        displayLeafNodes(root);
        cout << endl;
    }

    // Public function to perform an In-order traversal and display the tree
    void display() {
        cout << "In-order traversal: ";
        inorder(root);
        cout << endl;
    }
};

int main() {
    BinarySearchTree bst;

    // Insert some values into the BST
    bst.insert(50);
    bst.insert(30);
    bst.insert(20);
    bst.insert(40);
    bst.insert(70);
    bst.insert(60);
    bst.insert(80);

    // Display the tree in In-order (sorted order)
    bst.display();

    // Search for a value in the tree
    int searchValue = 40;
    if (bst.search(searchValue)) {
        cout << searchValue << " found in the tree." << endl;
    } else {
        cout << searchValue << " not found in the tree." << endl;
    }

    // Display the depth of the tree
    cout << "Depth of the tree: " << bst.depth() << endl;

    // Display all leaf nodes in the tree
    bst.displayLeafNodes();

    return 0;
}
